from jax import numpy as jnp

import flax


class AnchorUnpacker(flax.nn.Module):
  """A layer which unpacks all the anchors of an image into bboxes.
  """

  def _generate_base_anchors(self, size, ratios, scales, dtype=jnp.float32):
    """Generates candidate anchor shapes.

    Args:
      size: the size of the anchor box
      ratios: the aspect ratio of the anchor boxes
      scales: the scales of the anchor boxes

    Returns:
      The expanded anchors. The result will have the shape
      (|ratios| * |scales|, 4), where the elements on each row represent the
      upper left and lower right corners of the anchor box. The coordinates are
      relative to the origin, which is located in the center of the anchor box.
    """
    ratios = jnp.array(ratios, dtype=dtype)
    scales = jnp.array(scales, dtype=dtype)

    # Scales are replicated to enable vectorized computations
    adjusted_size = jnp.tile(scales, (2, ratios.shape[0])).T * size

    # The areas are required for extracting the correct height and width
    areas = adjusted_size[:, 0] * adjusted_size[:, 1]

    # Get the adjusted height and width, and shift the box centers in the origin
    replicated_ratios = jnp.repeat(ratios, scales.shape[0])
    heights = jnp.sqrt(areas / replicated_ratios) / 2.0
    widths = heights * replicated_ratios / 2.0
    anchors = jnp.stack((-heights, -widths, heights, widths), axis=1)

    return anchors

  def apply(self, shape, stride, size, ratios, scales, dtype=jnp.float32):
    """Applies anchor unpacking.

    Args:
      shape: a triple of the form (batch_size, height, width)
      stride: the stride of the current layer, relative to the original image
      size: the size of the window at this convolutional level
      ratios: the aspect ratios of the anchors
      scales: the scales of the anchor boxes

    Returns:
      A matrix of the shape (shape[0] * shape[1] * |ratios| * |scales|, 4).
      Each row in the returned matrix stores the coordinate of the upper left
      and lower right corner: [x1, y1, x2, y2].
    """
    # Get the anchors
    anchors = self._generate_base_anchors(size, ratios, scales, dtype=dtype)

    # Find the central points of the anchor boxes
    x_loc = jnp.arange(shape[2], dtype=dtype) * stride + 0.5
    y_loc = jnp.arange(shape[1], dtype=dtype) * stride + 0.5
    xx, yy = jnp.meshgrid(x_loc, y_loc)
    xx, yy = jnp.reshape(xx, -1), jnp.reshape(yy, -1)

    # Apply all anchor boxes to every spatial location in the image
    centers = jnp.stack((xx, yy), axis=1)
    centers = jnp.repeat(jnp.tile(centers, (1, 2)), anchors.shape[0], axis=0)
    centers = centers + jnp.tile(anchors, (xx.shape[0], 1))

    # Tile the map for each image in the batch
    return jnp.tile(jnp.expand_dims(centers, axis=0), (shape[0], 1, 1))


class BBoxRegressor(flax.nn.Module):
  """Applies the regression values to the generated bounding boxes.
  """

  def apply(self, anchors, regressions, means=None, devs=None,
            dtype=jnp.float32):
    """Applies the regression values to the raw anchor boxes.

    Args:
      anchors: a matrix which holds the anchor information
      regressions: the regression values generated by the
      means: a list of means across each of the regression dimensions
      devs: a list of standard deviations across each of the regression
               dimensions

    Returns:
      The adjusted anchor boxes, relative to the regressions. The shape will be
      the same as the `anchor` input.
    """
    if means is None:
      means = jnp.array([0] * anchors.shape[1], dtype=dtype)
    elif isinstance(means, (list, tuple)):
      means = jnp.array(means, dtype=dtype)

    if devs is None:
      devs = jnp.array([0.2] * anchors.shape[1], dtype=dtype)
    elif isinstance(devs, (list, tuple)):
      devs = jnp.array(devs, dtype=dtype)

    width = anchors[:, :, 2] - anchors[:, :, 0]
    height = anchors[:, :, 3] - anchors[:, :, 1]

    x1 = anchors[:, :, 0] + (regressions[:, :, 0] * devs[0] + means[0]) * width
    y1 = anchors[:, :, 1] + (regressions[:, :, 1] * devs[1] + means[1]) * height
    x2 = anchors[:, :, 2] + (regressions[:, :, 2] * devs[2] + means[2]) * width
    y2 = anchors[:, :, 3] + (regressions[:, :, 3] * devs[3] + means[3]) * height

    return jnp.stack((x1, y1, x2, y2), axis=-1)
